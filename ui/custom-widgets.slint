import { Theme } from "../ui/theme.slint";
import {  Palette, StyleMetrics } from "std-widgets.slint";

export component SliderHandle inherits Rectangle {
    in property <Orientation> orientation: vertical;
    property <length> handle_height: orientation == Orientation.vertical?10px:20px;
    property <length> handle_width: orientation == Orientation.vertical?20px:10px;
    property <length> handle_border_width: 4px;
    property <length> handle_radius: 5px;

    width: handle_width;
    height: handle_height;
    border-color: Theme.handle-border-colour;
    border-width: handle_border_width;
    border-radius: handle_radius;
    background: Theme.handle-background-colour;
}


export component SliderTrack inherits Rectangle {
    in property <Orientation> orientation: vertical;
    in-out property <length> track-width: orientation == Orientation.vertical?Theme.slider-track-width:Theme.slider-track-height;
    in-out property <length> track-height: orientation == Orientation.vertical?Theme.slider-track-height:Theme.slider-track-width;
    in-out property <length> position: orientation == Orientation.vertical?Theme.slider-track-height:self.x + Theme.slider-track-width;

    width: track-width;
    height: track-height;
    background: Theme.slider-track-colour;
    clip: true;

    indicator := Rectangle {
        x: orientation == Orientation.vertical?0px:position;
        y: orientation == Orientation.vertical?position:0px;
        width: parent.width;
        height: parent.height;
        background: Theme.slider-indicator-colour;
    }
}


export component VerticalSlider inherits Rectangle {
    in-out property <float> minimum: 0;
    in-out property <float> maximum: 100;
    in-out property <float> default-value: 0;
    callback updated(float);

    width: 50px;
    height: 100px;

    property <float> range_max: max(maximum, minimum);
    property <float> range_min: min(minimum, maximum);
    property <float> range: range_max - range_min;
    property <length> indicator-default-position: get_default_position(track.y, track.height, default-value);

    function get_default_position(track_start: length, track_end: length, value: float) -> length {
        let value_as_percent = (value.clamp(range_min, range_max) - range_min) / range;
        let scaled_position = track_start + track_end - (track_end * value_as_percent);
        return scaled_position;
    }

    function get_output_value(position: length) -> float {
        let position_as_percent = (track.height - position) / track.height;
        let scaled_value = range_max + (range * position_as_percent);
        return scaled_value;
    }

    function get_handle_position() -> length {
        return clamp(track.position - (handle.height/2), track.y, track.height - handle.height);
    }

    touch := TouchArea {
        moved => {
            track.position = clamp(self.mouse-y, track.y, track.y + track.height);
            handle.y = get_handle_position();
        }

        double-clicked => {
            track.position = indicator-default-position;
            handle.y = get_handle_position();
        }
    }

    handle := SliderHandle {
        z: 2;
        y: get_handle_position();
    }

    track := SliderTrack {
        track-height: parent.height;
        position: indicator-default-position;
    }
}



export component HorzontalSlider inherits Rectangle {
    in property <float> minimum: 0;
    in property <float> maximum: 100;
    in property <float> default-value: 0;
    callback updated(float);

    width: 100px;
    height: 50px;

    property <float> range_max: max(maximum, minimum);
    property <float> range_min: min(minimum, maximum);
    property <float> range: range_max - range_min;
    property <length> indicator-default-position: get_default_position(track.x, track.width, default-value);

    function get_default_position(track-start: length, track-end: length, value: float) -> length {
        let value_as_percent = (value.clamp(range_min, range_max) - range_min) / range;
        let scaled_position = track-start - track-end + (track-end * value_as_percent);
        return scaled_position;
    }

    function get_output_value(position: length) -> float {
        let position_as_percent = (position + track.width) / track.width;
        let scaled_value = range_min + (range * position_as_percent);
        return scaled_value;
    }

    function get_handle_position() -> length {
        return clamp(track.position + track.width - (handle.width/2), track.x, track.x + track.width - handle.width);
    }

    touch := TouchArea {
        width: parent.width;
        height: parent.height;

        moved => {
            track.position = self.mouse-x.clamp(track.x, track.x + track.width) - track.width;
             handle.x = get_handle_position();
        }

        double-clicked => {
           track.position = indicator-default-position;
           handle.x = get_handle_position();
        }
    }


    handle := SliderHandle {
        z: 2;
        orientation: horizontal;
        x: get_handle_position();
    }

    track := SliderTrack {
        orientation: horizontal;
        track-width: parent.width;
        position: indicator-default-position;
    }

}

/*
handle := Rectangle {
        z: 2;
        x: indicator-default-position + indicator.width - (handle-width / 2);
        width: handle-width;
        height: handle-height;
        border-color: Theme.handle-border-colour;
        border-width: handle-border-width;
        border-radius: handle-radius;
        background: Theme.handle-background-colour;
    }

    track := Rectangle {
        width: parent.width;
        height: track-height;
        background: Theme.slider-track-colour;
        clip: true;

        indicator := Rectangle {
            in-out property <length> position: indicator-default-position;
            x: position;
            width: parent.width;
            height: parent.height;
            background: Theme.slider-indicator-colour;

            changed x => {
                let output = get_output_value(self.x);
                updated(output);
                handle.x = clamp(indicator.x + indicator.width - (handle-width / 2), track.x, track.x + indicator.width - handle.width);
            }
        }
    }
*/