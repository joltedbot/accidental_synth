import { Theme } from "../ui/theme.slint";
import {  Palette, StyleMetrics } from "std-widgets.slint";

/*  Palette - Fluent Dark
    foreground - white
    background - dark gray
    alternate f - white
    alternate b - lighter dark grey than  background background
    control f - white
    control b - Transparent
    accent f - black
    accent b - Control tracks in the theme
    selection f - black
    selection b - other blue
*/

export component VerticalSlider inherits Rectangle {
    in-out property <float> minimum: 0;
    in-out property <float> maximum: 100;
    in-out property <float> default-value: 0;
    callback updated(float);


    width: 50px;
    height: 100px;
    property <length> track-width: 6px;
    property <length> handle-width: 20px;
    property <length> handle-height: 10px;
    property <length> handle-border-width: 4px;
    property <length> handle-radius: 5px;
    property <length> indicator-default-position: calculate_default_position(track.y, track.height, default-value);

    function calculate_default_position(track-start: length, track-end: length, value: float) -> length {
        let max = maximum > minimum?maximum:minimum;
        let min = minimum < maximum?minimum:maximum;

        let output_range = max - min;
        let value_as_percent =  (value.clamp(min, max) - min)/output_range;
        let scaled_position = track-start + track-end - (track-end * value_as_percent);
        return scaled_position;
    }

    function calculate_output_value(position: length) -> float {
        let max = maximum > minimum?maximum:minimum;
        let min = minimum < maximum?minimum:maximum;

        let output_range = max - min;
        let position_as_percent = (track.height - position) / track.height;
        let scaled_value = min + (output_range * position_as_percent);
        return scaled_value;
    }

    touch := TouchArea {
        width: parent.width;
        height: parent.height;

        moved => {
            indicator.position = self.mouse-y.clamp(track.y, track.y + track.height);
        }

        double-clicked => {
            indicator.position = indicator-default-position;
        }
    }

    handle := Rectangle {
        z: 2;
        y: indicator-default-position - (handle-height/2);
        width: handle-width;
        height: handle-height;
        border-color: Theme.handle-border-colour;
        border-width: handle-border-width;
        border-radius: handle-radius;
        background: Theme.handle-background-colour;
    }

    track := Rectangle {
        width: track-width;
        height: parent.height;
        background: Theme.slider-track-colour;
        clip: true;

        indicator := Rectangle {
            out property <length> position: indicator-default-position;
            y: position;
            width: parent.width;
            height: parent.height;
            background: Theme.slider-indicator-colour;

            changed y => {
                let output = calculate_output_value(self.y);
                updated(output);
                handle.y = clamp(self.y - (handle-height/2), parent.y, parent.y + parent.height - handle-height);
            }
        }
    }
}

export component HorzontalSlider inherits Rectangle {
    in property <float> minimum: 0;
    in property <float> maximum: 100;
    in property <float> default-value: 0;
    callback updated(float);


    width: 100px;
    height: 50px;
    property <length> track-height: 6px;
    property <length> handle-height: 20px;
    property <length> handle-width: 10px;
    property <length> handle-border-width: 4px;
    property <length> handle-radius: 5px;
    property <length> indicator-default-position: calculate_default_position(track.x, track.width, default-value);

    function calculate_default_position(track-start: length, track-end: length, value: float) -> length {
        let max = maximum > minimum?maximum:minimum;
        let min = minimum < maximum?minimum:maximum;

        let output_range = max - min;
        let value_as_percent =  (value.clamp(min, max) - min)/output_range;
        let scaled_position = track-start - track-end + (track-end * value_as_percent);
        return scaled_position;
    }

    function calculate_output_value(position: length) -> float {
        let max = maximum > minimum?maximum:minimum;
        let min = minimum < maximum?minimum:maximum;

        let output_range = max - min;
        let position_as_percent = (position + track.width) / track.width;
        let scaled_value = min + (output_range * position_as_percent);
        return scaled_value;
    }

    touch := TouchArea {
        width: parent.width;
        height: parent.height;

        moved => {
            indicator.position = self.mouse-x.clamp(track.x, track.x + track.width) - indicator.width
        }

        double-clicked => {
            indicator.position = indicator-default-position;
        }
    }

    handle := Rectangle {
        z: 2;
        x: indicator-default-position + indicator.width - (handle-width/2);
        width: handle-width;
        height: handle-height;
        border-color: Theme.handle-border-colour;
        border-width: handle-border-width;
        border-radius: handle-radius;
        background: Theme.handle-background-colour;
    }

    track := Rectangle {
        width: parent.width;
        height: track-height;
        background: Theme.slider-track-colour;
        clip: true;

        indicator := Rectangle {
            in-out property <length> position: indicator-default-position;
            x: position;
            width: parent.width;
            height: parent.height;
            background: Theme.slider-indicator-colour;

            changed x => {
                let output = calculate_output_value(self.x);
                updated(output);
                handle.x = clamp(indicator.x + indicator.width - (handle-width/2), track.x, track.x + indicator.width - handle.width);
            }
        }
    }
}
